<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Summary</title>
  <style>
    :root{
      --brand: #e6007e;
      --card-bg: #ffffff;
      --page-bg: #f5f6f8;
      --muted: #6b7280;
      --good: #16a34a;
      --bad: #dc2626;
      --accent: #111827;
      --yellow: #eab308;
      --light-green: #86efac;
      --bright-green: #16a34a;
      --red: #ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;background:var(--page-bg);font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,"Helvetica Neue",Arial,sans-serif;color:var(--accent);}
    header{
      background: #fff;
      border-bottom:1px solid #e8e8ed;
      padding:12px 16px;
      display:flex;
      flex-direction:column;
      align-items:center;
      position:sticky;
      top:0;
      z-index:20;
    }
    .logo{max-height:84px;width:auto;display:block;object-fit:contain;margin-bottom:8px;}
    .meta {
      width:100%;
      max-width:980px;
      display:flex;
      justify-content:center;
      gap:18px;
      align-items:center;
      color:var(--muted);
      font-size:13px;
      padding:0 16px 12px;
    }
    main{max-width:980px;margin:18px auto;padding:0 16px 48px;}
    h1{font-size:20px;margin:6px 0;color:var(--brand);text-align:left}
    .top-actions{display:flex;gap:10px;justify-content:flex-end;margin:6px 0 12px}
    .btn{background:var(--brand);color:#fff;border:none;padding:8px 12px;border-radius:10px;font-weight:800;cursor:pointer}
    .btn.secondary{background:#111;color:#fff}

    /* Main grid: 3 columns desktop, DORT and Revenue span 2 rows so the right column stacks */
    .grid{
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:14px;
      margin-top:6px;
      grid-auto-rows: minmax(140px, auto);
      align-items:start;
    }
    @media (max-width:1100px){ .grid{grid-template-columns:repeat(2,1fr);} }
    @media (max-width:640px){ .grid{grid-template-columns:1fr;} .logo{max-height:64px} }
    .span-2 { grid-row: span 2; }

    .card{
      background:var(--card-bg);
      border-radius:14px;
      padding:12px;
      box-shadow:0 8px 20px rgba(17,24,39,0.06);
      border:1px solid rgba(16,24,40,0.04);
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      height:100%;
    }
    .card-head{display:flex;align-items:center;gap:10px}
    .card-emoji{font-size:26px}
    .card-title{font-weight:800;font-size:16px}

    /* Uniform tile grid and tiles */
    .metric-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:10px;align-items:stretch}
    @media (max-width:640px){ .metric-grid{grid-template-columns:1fr} }

    .stat{
      background:linear-gradient(180deg,#fff,#fbfdff);
      border-radius:10px;padding:12px;border:1px solid #f0f3f7;display:flex;flex-direction:column;align-items:flex-start;justify-content:space-between;
      height:100%;
      min-height:86px;
    }
    .stat .label{font-size:13px;color:var(--muted);margin-bottom:6px;display:flex;align-items:center;gap:6px}
    .stat .label .emoji { font-size:16px; }
    .stat .value{font-weight:900;margin-top:0;font-size:18px;color:var(--accent)}
    .gap{font-weight:800;margin-top:6px}
    .gap.good{color:var(--good)}
    .gap.bad{color:var(--bad)}
    .progress{
      height:10px;border-radius:999px;background:#eef2f7;overflow:hidden;margin-top:10px;width:100%;
    }
    .progress > i{display:block;height:100%;width:0%;border-radius:999px;transition:width .6s ease, background-color .3s ease}
    .pbar-red{ background: linear-gradient(90deg, rgba(239,68,68,1), rgba(239,68,68,0.85)); }
    .pbar-yellow{ background: linear-gradient(90deg, rgba(234,179,8,1), rgba(234,179,8,0.9)); }
    .pbar-lightgreen{ background: linear-gradient(90deg, rgba(134,239,172,1), rgba(134,239,172,0.9)); }
    .pbar-brightgreen{ background: linear-gradient(90deg, rgba(22,163,74,1), rgba(22,163,74,0.9)); }

    /* goal tile specific: center content and enlarge number */
    .stat.goal{ display:flex; align-items:center; justify-content:center; text-align:center; padding:10px; }
    .stat.goal .value{ font-size:40px; line-height:1; margin:0; }

    .small{font-size:12px;color:var(--muted);margin-top:6px}
    .section-full{grid-column:1/-1}
    .state-pill{margin-left:auto;padding:6px 10px;border-radius:999px;color:#fff;font-weight:800;font-size:13px}
    .state-good{background:var(--good)}
    .state-bad{background:var(--red)}
    .state-neutral{background:var(--muted)}

    /* ---------------- PRINT RULES - aim to fit single page ---------------- */
    @page { size: A4 landscape; margin: 8mm; }

    @media print {
      html, body { background: white; color: black; }
      header { position:fixed; top:0; left:0; right:0; box-shadow:none; border:none; padding-bottom:6px; background:#fff; }
      main { margin-top:120px; } /* space for header */
      .top-actions, .btn { display:none !important; }
      .grid { gap:6px; grid-auto-rows: minmax(110px, auto); }
      .card { padding:8px; border-width:1px; box-shadow:none; }
      .metric-grid { gap:6px; }
      .stat { padding:8px; min-height:64px; }
      .stat .label { font-size:11px; }
      .stat .value { font-size:15px; }
      .small { font-size:11px; }
      .stat.goal .value { font-size:34px; }
      * {-webkit-print-color-adjust: exact; color-adjust: exact; }
    }
  </style>
</head>
<body>
  <header>
    <img id="siteLogo" class="logo" src="/logo-256.png" alt="Company logo">
    <div class="meta" id="metaBar" aria-hidden="false">
      <div id="metaDate">‚Äî</div>
      <div id="metaTime">‚Äî</div>
      <div id="metaStore">‚Äî</div>
    </div>
  </header>

  <main id="mainContent">
    <div class="top-actions">
      <button class="btn" id="printBtn">üñ® Print</button>
      <button class="btn secondary" id="backBtn">‚Üê Back</button>
    </div>

    <div id="cards" class="grid" aria-live="polite">
      <!-- Cards injected by JS -->
    </div>
  </main>

<script>
(async function(){
  // Try to reuse embedded logo if available
  const logoImg = document.getElementById('siteLogo');
  try {
    const r = await fetch('/app/dort.html', {cache:'no-store'});
    if (r.ok) {
      const t = await r.text();
      const m = t.match(/data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+/);
      if (m && m[0]) logoImg.src = m[0];
    }
  } catch(e){ /* ignore */ }

  // Meta elements
  const metaDate = document.getElementById('metaDate');
  const metaTime = document.getElementById('metaTime');
  const metaStore = document.getElementById('metaStore');

  function getStoreName() {
    return localStorage.getItem('ggt.store') ||
           (function(){
             try {
               const s = JSON.parse(localStorage.getItem('ggt_selection') || 'null');
               return s && (s.store || s.store_name || s.storeName);
             } catch(e){ return null; }
           })() ||
           localStorage.getItem('store') || localStorage.getItem('store_name') || 'Unknown store';
  }

  function updateMeta() {
    const now = new Date();
    metaDate.textContent = now.toLocaleDateString(undefined, { year:'numeric', month:'short', day:'numeric' });
    metaTime.textContent = now.toLocaleTimeString(undefined, { hour:'numeric', minute:'2-digit', second:'2-digit' });
    metaStore.textContent = getStoreName();
  }
  updateMeta();
  setInterval(updateMeta, 1000);

  // helpers
  function n(v){ const x = parseFloat(v); return isNaN(x)?0:x; }
  function i(v){ const x = parseInt(v); return isNaN(x)?0:x; }
  function money(v){ return '$' + Number(n(v)).toFixed(2); }
  function pct(v){ return Math.round(n(v)); }
  function ls(k){ return localStorage.getItem(k); }
  function getOr(k, def){ const v = ls(k); return v===null ? def : v; }

  function comb(ad, gd, as, gs){
    const att = i(getOr(ad,0)) + i(getOr(as,0));
    const goal= i(getOr(gd,0)) + i(getOr(gs,0));
    const pctv = goal>0 ? Math.round((att/goal)*100) : 0;
    const gap = goal - att;
    return { att: att, goal: goal, pct: pctv, gap: gap };
  }

  function computeAll(){
    const voice = comb('d_v_att','d_v_goal','s_v_att','s_v_goal');
    const bts   = comb('d_b_att','d_b_goal','s_b_att','s_b_goal');
    const tfb   = comb('d_t_att','d_t_goal','s_t_att','s_t_goal');
    const acc   = comb('d_a_att','d_a_goal','s_a_att','s_a_goal');

    const pOpp = i(getOr('p_opp',0));
    const pPctIn = Math.max(0, Math.min(100, n(getOr('p_pct',0))));
    const pAtt = Math.round(pOpp*(pPctIn/100));
    const pTargetPct = 60;
    const tP = pTargetPct/100;
    const pNeed = Math.max(0, Math.ceil((tP*pOpp - pAtt) / (1 - tP)));

    const vOpp = i(getOr('v_opp',0));
    const vTot = n(getOr('v_total',0));
    const vTarget = 19;
    const needTotal = vTarget * vOpp;
    const vGap = Math.max(0, needTotal - vTot);
    const mrc = vOpp>0 ? (vTot/vOpp) : 0;

    const cAvg = n(getOr('c_score',0));
    const cN = i(getOr('c_surveys',0));
    const cNeed = cAvg>=9.5 ? 0 : Math.max(0, Math.ceil(2 * cN * (9.5 - cAvg)));

    const tlPct = Math.max(0, Math.min(100, n(getOr('t2_att',0))));
    const tlOpp = i(getOr('t2_opp',0));
    const tlSuc = Math.round(tlOpp*(tlPct/100));
    const tlTarget = 70;
    const tT = tlTarget/100;
    const tlNeed = Math.max(0, Math.ceil((tT*tlOpp - tlSuc) / (1 - tT)));

    const gVoice = getOr('g_voice','‚Äî');
    const gBts   = getOr('g_bts','‚Äî');
    const gAcc   = getOr('g_acc','‚Äî');
    const gTfb   = getOr('g_tfb','‚Äî');

    return {
      dortsort: { voice, bts, tfb, acc },
      p360: { pOpp, pPctIn, pAtt, pNeed, pTargetPct },
      vaf: { vOpp, vTot, vTarget, needTotal, vGap, mrc },
      csat: { cAvg, cN, cNeed },
      tlife: { tlPct, tlOpp, tlSuc, tlTarget, tlNeed },
      goals: { voice: gVoice, bts: gBts, acc: gAcc, tfb: gTfb }
    };
  }

  function progressClassFor(pct){
    if (pct < 80) return 'pbar-red';
    if (pct >= 80 && pct <= 99) return 'pbar-yellow';
    if (pct >= 100 && pct <= 124) return 'pbar-lightgreen';
    return 'pbar-brightgreen';
  }

  function el(tag, attrs={}, children=[]){
    const e = document.createElement(tag);
    for (const k in attrs){
      if (k === 'class') e.className = attrs[k];
      else if (k === 'text') e.textContent = attrs[k];
      else e.setAttribute(k, attrs[k]);
    }
    if (!Array.isArray(children)) children = [children];
    children.forEach(c => { if (typeof c === 'string') e.insertAdjacentHTML('beforeend', c); else if (c) e.appendChild(c); });
    return e;
  }

  function statBlock(label, att, goal, pct, gap, opts){
    opts = opts || {};
    const s = el('div',{class:'stat'});
    const lbl = el('div',{class:'label'});
    lbl.innerHTML = label;
    s.appendChild(lbl);

    const valText = opts.currency ? (money(att) + ' / ' + money(goal) + ' (' + pct + '%)') : (att + ' / ' + goal + ' (' + pct + '%)');
    s.appendChild(el('div',{class:'value',text: valText}));

    const gText = opts.currency ? money(gap) : (gap<=0?('+'+Math.abs(gap)):('-'+gap));
    const g = el('div',{class:'gap ' + (gap<=0 ? 'good' : 'bad'), text: gText});
    s.appendChild(g);

    const p = el('div',{class:'progress'}); const i = el('i');
    p.appendChild(i);
    s.appendChild(p);
    const pctNum = Number(pct) || 0;
    i.style.width = Math.min(200, Math.max(0, pctNum)) + '%';
    i.classList.add(progressClassFor(pctNum));
    return { node: s, bar: i };
  }

  function render(){
    const out = computeAll();
    const grid = document.getElementById('cards');
    grid.innerHTML = '';

    // DORT + SORT (left column) - span 2 rows to match stacked right column
    const ds = el('section',{class:'card span-2'});
    const head = el('div',{class:'card-head'});
    head.appendChild(el('div',{class:'card-emoji',text:'üìä'}));
    head.appendChild(el('div',{class:'card-title',text:'DORT + SORT'}));
    const anyGap = out.dortsort.voice.gap + out.dortsort.bts.gap + out.dortsort.tfb.gap + out.dortsort.acc.gap;
    head.appendChild(el('div',{class:'state-pill '+(anyGap<=0 ? 'state-good' : 'state-bad'), text: anyGap <= 0 ? 'On Track' : 'Gaps'}));
    ds.appendChild(head);

    const mg = el('div',{class:'metric-grid'});
    const v = out.dortsort.voice, b = out.dortsort.bts, t = out.dortsort.tfb, a = out.dortsort.acc;
    const sv = statBlock('Voice', v.att, v.goal, v.pct, v.gap);
    const sb = statBlock('BTS', b.att, b.goal, b.pct, b.gap);
    const st = statBlock('TFB', t.att, t.goal, t.pct, t.gap);
    const sa = statBlock('Accessories', a.att, a.goal, a.pct, a.gap, {currency: true});
    mg.appendChild(sv.node); mg.appendChild(sb.node); mg.appendChild(st.node); mg.appendChild(sa.node);
    ds.appendChild(mg);
    grid.appendChild(ds);

    // Revenue (center column) - span 2 rows to match left column
    const rev = el('section',{class:'card span-2'});
    const rhead = el('div',{class:'card-head'});
    rhead.appendChild(el('div',{class:'card-emoji',text:'üíµ'}));
    rhead.appendChild(el('div',{class:'card-title',text:'Revenue'}));
    rev.appendChild(rhead);

    const revGrid = el('div',{class:'metric-grid'});

    // VAF tile
    const vPercent = out.vaf.vTarget > 0 ? Math.round((out.vaf.mrc / out.vaf.vTarget) * 100) : 0;
    const vafTile = el('div',{class:'stat'});
    vafTile.appendChild(el('div',{class:'label',text:'VAF'}));
    vafTile.appendChild(el('div',{class:'value',text: money(out.vaf.mrc)}));
    vafTile.appendChild(el('div',{class:'small',text: 'Target: ' + money(out.vaf.vTarget) + ' /op ‚Ä¢ Opp: ' + out.vaf.vOpp}));
    const vafProgress = el('div',{class:'progress'});
    const vafBar = el('i'); vafBar.style.width = Math.min(200, Math.max(0, vPercent)) + '%'; vafBar.classList.add(progressClassFor(vPercent));
    vafProgress.appendChild(vafBar);
    vafTile.appendChild(vafProgress);
    revGrid.appendChild(vafTile);

    // VAF Gap (no progress)
    const vafGap = el('div',{class:'stat'});
    vafGap.appendChild(el('div',{class:'label',text:'VAF Gap'}));
    vafGap.appendChild(el('div',{class:'value',text: money(out.vaf.vGap)}));
    vafGap.appendChild(el('div',{class:'small',text: out.vaf.vGap <= 0 ? 'On or above target' : 'Behind target'}));
    revGrid.appendChild(vafGap);

    // P360 percent
    const pPct = el('div',{class:'stat'});
    pPct.appendChild(el('div',{class:'label',text:'P360 ‚Äî Current %'}));
    pPct.appendChild(el('div',{class:'value',text: (out.p360.pPctIn || 0) + '%'}));
    pPct.appendChild(el('div',{class:'small',text: 'Attained: ' + out.p360.pAtt + ' / ' + out.p360.pOpp}));
    const pPctProgress = el('div',{class:'progress'});
    const pPctBar = el('i'); const pPctVal = Math.min(200, Math.max(0, out.p360.pPctIn || 0));
    pPctBar.style.width = pPctVal + '%'; pPctBar.classList.add(progressClassFor(pPctVal));
    pPctProgress.appendChild(pPctBar); pPct.appendChild(pPctProgress);
    revGrid.appendChild(pPct);

    // P360 adds needed (no progress)
    const pNeed = el('div',{class:'stat'});
    pNeed.appendChild(el('div',{class:'label',text:'P360 ‚Äî Adds Needed to ' + out.p360.pTargetPct + '%'}));
    pNeed.appendChild(el('div',{class:'value',text: out.p360.pNeed}));
    pNeed.appendChild(el('div',{class:'small',text: out.p360.pNeed > 0 ? 'Work to do' : 'On target'}));
    revGrid.appendChild(pNeed);

    rev.appendChild(revGrid);
    grid.appendChild(rev);

    // Right column: CSAT (top) and T-Life (bottom) stacked; together they match left/center height
    const cs = el('section',{class:'card'});
    const csHead = el('div',{class:'card-head'});
    csHead.appendChild(el('div',{class:'card-emoji',text:'üòä'}));
    csHead.appendChild(el('div',{class:'card-title',text:'CSAT'}));
    cs.appendChild(csHead);

    const csInner = el('div',{class:'metric-grid'});
    const csStat = el('div',{class:'stat'});
    csStat.appendChild(el('div',{class:'label',text:'Average Score'}));
    csStat.appendChild(el('div',{class:'value',text: (out.csat.cAvg || 0).toFixed(1) + ' / 10'}));
    csStat.appendChild(el('div',{class:'small',text:'Surveys: '+ (out.csat.cN || 0)}));
    csInner.appendChild(csStat);

    const csNeed = el('div',{class:'stat'});
    csNeed.appendChild(el('div',{class:'label',text:'Needed Perfect 10s'}));
    csNeed.appendChild(el('div',{class:'value',text: out.csat.cNeed}));
    csNeed.appendChild(el('div',{class:'small',text:'Target: 9.5'}));
    csInner.appendChild(csNeed);

    cs.appendChild(csInner);
    grid.appendChild(cs);

    // T-Life
    const tl = el('section',{class:'card'});
    const tlH = el('div',{class:'card-head'});
    tlH.appendChild(el('div',{class:'card-emoji',text:'üì±'}));
    tlH.appendChild(el('div',{class:'card-title',text:'T‚ÄëLife'}));
    tl.appendChild(tlH);

    const tlInner = el('div',{class:'metric-grid'});
    const t1 = el('div',{class:'stat'});
    t1.appendChild(el('div',{class:'label',text:'Attainment'}));
    t1.appendChild(el('div',{class:'value',text: out.tlife.tlPct + '%'}));
    t1.appendChild(el('div',{class:'small',text:'Target: ' + out.tlife.tlTarget + '%'}));
    const t1p = el('div',{class:'progress'});
    const t1bar = el('i'); const tPctVal = Math.min(200, Math.max(0, out.tlife.tlPct || 0));
    t1bar.style.width = tPctVal + '%';
    if ((out.tlife.tlPct || 0) >= (out.tlife.tlTarget || 70)) { t1bar.classList.add('pbar-brightgreen'); } else { t1bar.classList.add('pbar-red'); }
    t1p.appendChild(t1bar); t1.appendChild(t1p);
    tlInner.appendChild(t1);

    const t2 = el('div',{class:'stat'});
    t2.appendChild(el('div',{class:'label',text:'Needed Opportunities'}));
    t2.appendChild(el('div',{class:'value',text: out.tlife.tlNeed}));
    t2.appendChild(el('div',{class:'small',text: 'Opportunities: ' + out.tlife.tlOpp}));
    tlInner.appendChild(t2);

    tl.appendChild(tlInner);
    grid.appendChild(tl);

    // Daily goals (full width below)
    const goalsCard = el('section',{class:'card section-full'});
    const ghead = el('div',{class:'card-head'});
    ghead.appendChild(el('div',{class:'card-emoji',text:'üéØ'}));
    ghead.appendChild(el('div',{class:'card-title',text:'Daily Goals'}));
    goalsCard.appendChild(ghead);

    const gGrid = el('div',{class:'metric-grid'});
    const gg = out.goals;
    function goalTile(name, emoji, value){
      const t = el('div',{class:'stat goal'});
      const lbl = el('div',{class:'label'});
      lbl.innerHTML = '<span class="emoji">' + emoji + '</span> ' + name;
      t.appendChild(lbl);
      const displayVal = (name === 'Accessories') ? money(value) : value;
      t.appendChild(el('div',{class:'value',text: displayVal }));
      return t;
    }
    gGrid.appendChild(goalTile('Voice','üìû', gg.voice));
    gGrid.appendChild(goalTile('BTS','‚åö', gg.bts));
    gGrid.appendChild(goalTile('TFB','üíº', gg.tfb));
    gGrid.appendChild(goalTile('Accessories','üéß', gg.acc));
    goalsCard.appendChild(gGrid);
    grid.appendChild(goalsCard);

    // color numeric gap labels
    document.querySelectorAll('.gap').forEach(g => {
      const num = parseFloat(String(g.textContent).replace(/[^0-9.-]/g,''));
      if (isNaN(num)) return;
      if (String(g.textContent).trim().startsWith('+')) g.classList.add('good'); else g.classList.add('bad');
    });
  }

  // initial render and re-render on storage events
  try { render(); } catch(e){ console.error('Summary render failed', e); document.getElementById('cards').textContent = 'An error occurred while rendering the summary. See console.'; }
  window.addEventListener('storage', () => { try { render(); } catch(e){} });

  // ---------------- PRINT FIT LOGIC ----------------
  // We'll compute a scale to make the #mainContent fit a single landscape A4 page,
  // apply it just before printing, then reset after print completes.
  const mainEl = document.getElementById('mainContent');

  // conversion constants for mm -> px at 96dpi (approx)
  const mmToPx = 3.7795275591;

  function computePrintScaleForA4Landscape() {
    // Paper size A4 landscape in mm: 297 x 210
    const paperWmm = 297, paperHmm = 210;
    const marginMm = 8; // matches @page margin
    const availW = (paperWmm - 2*marginMm) * mmToPx;
    const availH = (paperHmm - 2*marginMm) * mmToPx;

    // measure content size (cards + header)
    // we include header height (logo + meta) as printed header space is reserved by CSS (main margin-top)
    const headerRect = document.querySelector('header').getBoundingClientRect();
    const mainRect = mainEl.getBoundingClientRect();
    const contentW = Math.max(mainRect.width, mainEl.scrollWidth);
    const contentH = headerRect.height + Math.max(mainRect.height, mainEl.scrollHeight);

    // Compute scale to fit both width and height
    const scaleW = availW / contentW;
    const scaleH = availH / contentH;
    let scale = Math.min(scaleW, scaleH, 1);

    // don't scale below 0.5 to keep readability
    if (scale < 0.5) scale = 0.5;
    return scale;
  }

  // apply scale: we scale the #mainContent container and also increase its width so scaled layout keeps proportions
  function applyPrintScale() {
    const scale = computePrintScaleForA4Landscape();
    // store previous styles to restore later
    mainEl.dataset._prevTransform = mainEl.style.transform || '';
    mainEl.dataset._prevTransformOrigin = mainEl.style.transformOrigin || '';
    mainEl.dataset._prevWidth = mainEl.style.width || '';
    document.documentElement.dataset._prevOverflow = document.documentElement.style.overflow || '';
    // apply
    mainEl.style.transformOrigin = 'top left';
    mainEl.style.transform = 'scale(' + scale + ')';
    // set width to compensate so content doesn't wrap unexpectedly
    mainEl.style.width = (100 / scale) + '%';
    // hide scrollbars when printing
    document.documentElement.style.overflow = 'visible';
  }

  function resetPrintScale() {
    // restore
    if (mainEl.dataset._prevTransform !== undefined) mainEl.style.transform = mainEl.dataset._prevTransform;
    if (mainEl.dataset._prevTransformOrigin !== undefined) mainEl.style.transformOrigin = mainEl.dataset._prevTransformOrigin;
    if (mainEl.dataset._prevWidth !== undefined) mainEl.style.width = mainEl.dataset._prevWidth;
    if (document.documentElement.dataset._prevOverflow !== undefined) document.documentElement.style.overflow = document.documentElement.dataset._prevOverflow;
    // cleanup data attrs
    delete mainEl.dataset._prevTransform;
    delete mainEl.dataset._prevTransformOrigin;
    delete mainEl.dataset._prevWidth;
    delete document.documentElement.dataset._prevOverflow;
  }

  // Bind to print events so print button or browser print both get scaling
  window.addEventListener('beforeprint', applyPrintScale);
  window.addEventListener('afterprint', resetPrintScale);
  if (window.matchMedia) {
    const m = window.matchMedia('print');
    m.addListener((e) => {
      if (e.matches) applyPrintScale();
      else resetPrintScale();
    });
  }

  // Print button: ensure we apply scale, then call print(), then reset if afterprint doesn't fire
  document.getElementById('printBtn').addEventListener('click', () => {
    try {
      // Apply scale synchronously first so browsers pick it up in print preview
      applyPrintScale();
      // Delay slightly to allow paint before print dialog opens
      setTimeout(() => {
        try {
          window.print();
        } finally {
          // Some browsers don't reliably fire afterprint in all contexts; schedule a fallback reset
          setTimeout(resetPrintScale, 1200);
        }
      }, 250);
    } catch (err) {
      console.error('Print failed', err);
      // still attempt to print
      window.print();
    }
  });

  // Back button
  document.getElementById('backBtn').addEventListener('click', () => location.href = 'goals.html');

})();
</script>
</body>
</html>
